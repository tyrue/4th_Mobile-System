# 식사하는 철학자들(Dining Philosophers)

## 1. 개요

식사하는 철학자들 문제는 전산학에서 동시성과 교착 상태를 설명하는 예시로, 여러 프로세스가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다.

 ![image](https://user-images.githubusercontent.com/20302410/51963180-1363f600-24a6-11e9-8fa2-ca2b40589b1c.png)

문제는 다음과 같다. 다섯 명의 철학자가 원탁에 앉아 있고, 식탁의 중앙에 스파게티가 있고, 양옆에 젓가락이 한 짝씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다.(즉 서로 언제 먹을지 협상이 안 된다.) 이때, 철학자가 스파게티를 먹기 위해서는 양 옆의 젓가락 짝을 동시에 들고 있어야 한다.



## 2. 문제

각각의 철학자가 왼쪽의 젓가락 짝을 들고, 그 다음 오른쪽의 젓가락 짝을 들어서 스파게티를 먹는 알고리즘을 가지고 있다고 하자. 만약 다섯 철학자가 동시에 왼쪽의 젓가락 짝을 들고 있다면, 철학자 모두 오른쪽의 젓가락 짝을 들 때까지 무한정 기다리는 교착 상태에 빠지게 될 수 있다. 왜냐하면 모두 한 짝씩 들고 있기 때문에 식탁에 남아있는 젓가락이 없기 때문이다.

또한 어떤 경우에는 동시에 젓가락 양짝을 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

즉, 이 문제를 해결하기 위해 고려해야 하는 상황은 다음과 같다.

1. 기아상태에 빠지면 안 된다. ( 다들 한 번 이상씩은 식사를 해야 한다. 계속 굶은 철학자가 있으면 안 된다.)

2. 교착상태에 빠지면 안 된다. ( 즉, 한 번에 한 명은 반드시 식사를 해야 한다.)

3. 임계영역은 반드시 지켜져야 한다. (즉, 두 명의 철학자가 동시에 같은 포크를 사용할 수 없다.) **임계영역이란? 공유하는 자원을 의미한다.

   

## 3. 해결 방법

비대칭 해결안 : **짝수** 번호 철학자들은 **왼쪽** 젓가락을 먼저 집고 **홀수** 번호 철학자들은 **오른쪽** 젓가락을 먼저 집도록 한다. 

예) 2번 철학자는 2번 젓가락을 먼저 집고, 3번 철학자는 역시 2번 젓가락을 먼저 집도록 한다.



## 4. 주요 함수들

1.  pthread 함수들

   **pthread_mutex_t mutexes[NUM_THREADS]** : 뮤텍스 생성, 공유 자원 공간에 대한 접근 시간 제어로 동기화를 달성한다.

   **pthread_cond_t conditionVars[NUM_THREADS]**: 각 스레드의 상태 값, 정적으로 초기화한다.

   **int permits[NUM_THREADS]**: 포크 사용 여부, TRUE면 사용 가능

   **pthread_t tids[NUM_THREADS]**: 스레드ID를 생성하여 각 스레드를 식별한다, tids배열에 저장

   **pthread_mutex_lock(&mutexes[philosopher_number%NUM_THREADS])**: 해당 철학자 번호(왼쪽 포크)의 뮤텍스를 잠근다. 즉, 임계구역 설정. 만약 잠그려는 뮤텍스가 다른 쓰레드에 의해서 이미 잠겨있다면, 이미 잠근 다른 쓰레드가 뮤텍스의 잠금을 해제 할때까지 봉쇄(블럭)되게 된다. 

   **pthread_cond_wait(&conditionVars[philosopher_number%NUM_THREADS],**                     **&mutexes[philosopher_number%NUM_THREADS])**: 동작중인 쓰레드를 잠시 중단시킨다. 다른 스레드로부터 signal이나 broadcast를 받았을 경우 깨어나서 mutex_lock을 한다.

   **pthread_mutex_unlock(&mutexes[philosopher_number%NUM_THREADS])**: 쓰레드를 실행을 끝내고 종료하기 전에 자신이 가지고 있는 mutex를 풀어준다. 만약 이를 실행하지 않으면 다른 쓰레드는 mutex가 풀릴 때 까지 대기해야함

   **pthread_mutex_init(&mutexes[i], NULL)**: 뮤텍스값을 초기화 한다.

   **pthread_cond_init(&conditionVars[i], NULL)**: 상태를 NULL로 초기화한다

   **pthread_create(&tids[i], NULL, Philosopher, (void\*)(i))**: 스레드(철학자) 생성, 철학자 함수를 계속 실행하고 있다.

   **pthread_join(tids[i], NULL)**: 보조 스레드(철학자 스레드)가 종료 될 때까지 메인스레드(main)가 대기 하도록 하는 함수. 

   **pthread_mutex_destroy(&mutexes[i])** **pthread_cond_destroy(&conditionVars[i])**:  쓰레드, 상태값 파괴. 

   

2.  동작을 위한 함수들

   **void** **pickup_forks(****int** **philosopher_number)** : 포크를 집는 함수. 해당 번호의 철학자는 포크를 집기 위해 뮤텍스를 사용하여 임계구역을 설정하고, 해당 포크를 다른 철학자들이 사용 불가능 하도록 한다.

   **void** **return_forks(****int** **philosopher_number)** : 포크를 내려놓는 함수. 해당 번호의 철학자는 집고 있던 포크를 내려놓기 위해 뮤텍스를 사용하여 임계구역을 설정한 후, 다른 철학자 들이 포크를 사용 가능하게 한다.

   **void***** Philosopher(****void** *** arg)** : 짝수 번째 철학자 함수, 철학자는 왼쪽 포크를 먼저 집고, 내려놓을 때는 오른쪽 포크를 먼저 내려 놓는다.

   **void** *** OddPhilosopher(****void** *** arg)** : 홀수 번째 철학자 함수, 철학자는 오른쪽 포크를 먼저 집고, 내려놓을 때는 왼쪽 포크를 먼저 내려 놓는다.

   **int** **main()** : 메인 함수, 스레드를 생성하고 각 스레드가 동작을 하도록 한다.

**pthread_mutex_t mutexes[NUM_THREADS]** : 뮤텍스 생성, 공유 자원 공간에 대한 접근 시간 제어로 동기화를 달성한다.

## 5. 흐름

1) 뮤텍스, 상태값을 생성하고 초기화 한다.

2) 포크의 사용 여부를 모두 가능하게 한다.

3) 스레드를 0~4번 순서대로 생성함과 동시에 동작하도록 한다.

4) 짝수 철학자는 왼쪽 포크를 먼저 집고, 홀수 철학자는 오른쪽 포크를 집도록 한다.

5) 철학자가 포크를 집을 때, 먼저 해당 포크에 대한 뮤텍스를 잠궈 다른 철학자가 접근하지 못하게 한다.

6) 만약 집으려는 포크가 이미 다른 철학자 손에(사용 불가능 상태)있다면 포크가 다시 사용 가능 할 때까지 대기 하도록 한다. 대기 할 때는 포크번호에 대한 상태값을 가진다.

7) 대기 중에 해당 번호의 포크가 사용가능 해지면(signal을 받으면) 다른 철학자가 사용하지 못하도록 사용 불가능 하도록 하고, 뮤텍스를 풀어준다.

8) 철학자는 양손에 포크를 들어야 식사를 시작할 수 있다. 식사를 마치고 나면 왼쪽 철학자는 오른쪽 포크를 먼저 놓고, 오른쪽 철학자는 왼쪽 포크를 먼저 놓는다. 

9) 모든 철학자가 식사를 마치면 각 스레드는 동작을 멈추고, 마지막에 뮤텍스와 상태값을 파괴하여 메모리를 반납한다.

10) 각 철학자는 5번 식사를 하도록 한다.



## 6. 실행 화면

![image](https://user-images.githubusercontent.com/20302410/51963198-22e33f00-24a6-11e9-9fe4-f7d54d502302.png)



처음에 포크를 집는 순서를 보면 0, 1, 3번이다. 스레드를 0번부터 생성하자마자 동작시키기 때문에 예상한대로 0번 철학자가 먼저 포크를 집게 되었다. 2번 철학자는 1번 철학자가 먼저 포크를 집었기 때문에 다시 내려놓을 때까지 대기하므로 가장 마지막에 집게 되었다.

처음 먹는 순서를 보면 0, 3, 1, 4, 2번이고, 후반부에 5번 다 먹은 철학자의 순서를 보면 0, 1, 3, 2, 4이다. 0번이 먼저 시작해서 먼저 끝을 낸 것을 볼 수 있다. 그리고 처음과 끝의 먹는 순서가 달라짐으로서 스레드가 생성한 이후로는 동시적으로 동작한다고 볼 수 있다. 